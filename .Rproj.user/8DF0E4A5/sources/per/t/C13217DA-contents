#library("MASS")
library("tweeDEseq")

n = 50
t = 5
beta = c(4.1, 0.2, 0.3, 0)
D = 3
a = -2
Sigma = 1.5

Sigma = as.matrix(Sigma)

id = rep(1:n, each = t)
gender = rep(rbinom(n,1,0.5), each = t)
time = rep(1:t, n)
X = cbind(1, time, gender, gender*time)
Z = as.matrix(X[,1])
ranef.matr = as.matrix(rnorm(n, 0, Sigma))
rand.int = rep(ranef.matr[,1], each = t)
log.mu.ij = c(X %*% beta) + rand.int
N = n*t
y = rep(NA, N)
for (i in 1:N) y[i] = rPT(1, mu = exp(log.mu.ij[i]), D, a,
                          max = 300*sqrt(exp(log.mu.ij[i])*D),
                          tol = 1e-4)
data.long <- data.frame(id = id, time = time, gender = gender, y = y)

ls <- ls()
keep <- "data.long"
rm(list = c("keep", "ls", ls[!ls %in% keep]))

beta2 <- beta
beta2[1] <- beta2[1] + 0.001
sum(log(dPT(data.long$y, mu = 221, D = 3, a = -2, tol = 1e-300)))
sum(log(dPT(data.long$y, mu = 221 + 0.001, D = 3, a = -2, tol = 1e-300)))



#####################################################################################

fm <- mixed_model(fixed = y ~ time * gender, random = ~ 1 | id, data = data.long,
                  family = poisson(), nAGQ = 15)

summary(fm)

gm <- mixed_model(fixed = y ~ time * gender, random = ~ 1 | id, data = data.long,
                  family = negative.binomial(1), nAGQ = 15)

summary(gm)

km <- mixed_model(fixed = y ~ time * gender, random = ~ 1 | id, data = data.long,
                  family = poisson.tweedie(), n_phis = 2, nAGQ = 15, verbose = TRUE,
                  iter_EM = 0,
                  initial_values = list(betas = gm$coefficients, D = gm$D))

summary(km)

#####################################################################################

x = data.long$y
mu = exp(c(X %*% beta))
p = c(D, a)
    
dPT2 <- function (x, mu, p, tol = 1e-323) {
    x.t <- table(x)
    x.unique <- as.numeric(names(x.t))
    mm <- max(x.unique)
    nn <- length(x.unique)
    D <- p[1L]
    a <- p[2L]
    b <- (mu * (1 - a)^(1 - a)) / ((D - 1) * (D - a)^(-a))
    c <- (D - 1) / (D - a)
    log_prx <- if (abs(a) < 0.001) {
        dnbinom(0:mm, mu = mu, size = b, log = TRUE)
    } else if (a <= 1 - 0.001) {
        prx <- .Call("zhuprobs", as.integer(mm), a, b, c, tol, PACKAGE = "tweeDEseq")
        log(prx)
    } else {
        dpois(0:mm, b, log = TRUE)
    }
    log_prx[x + 1] * x
}

poisson.tweedie <- function (link = "log") {
    stats <- make.link(link)
    log_dens <- function (y, eta, mu_fun, phis) {
        mu_y <- mu_fun(eta)
        out <- if (is.matrix(mu_y)) {
            apply(mu_y, 2, dPT2, x = y, p = c(1 + exp(phis[1L]), 1 - exp(phis[2L])))
        } else {
            dPT2(x = y, mu = mu_y, p = c(1 + exp(phis[1L]), 1 - exp(phis[2L])))
        }
        out[is.na(out)] <- 0
        out[out == -Inf] <- -1e05
        attr(out, "mu_y") <- mu_y
        out
    }
    structure(list(family = "poisson tweedie", link = link, linkfun = stats$linkfun,
                   linkinv = stats$linkinv, log_dens = log_dens), class = "family")
}

fixed = y ~ time * gender
random = ~ 1 | id
data = data.long
control = list()
family = poisson.tweedie()
n_phis = 2
#family = negative.binomial(1)
#n_phis = 1
initial_values = list(betas = gm$coefficients, D = gm$D)
na.action = na.exclude

control = con
initial_values = inits

tweeDEseq:::loglikPoissonTweedie
d = 1 + exp(p[1])
a = 1 - exp(p[2])


